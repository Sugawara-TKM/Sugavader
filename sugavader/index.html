<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sugavader</title>
  <style>
    html, body { margin: 0; height: 100%; background:#0b0f14; }
    canvas { display:block; margin:0 auto; background:#05070a; }
  </style>
</head>
<body>
<canvas id="c" width="900" height="600"></canvas>
<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  // --- Utils
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const aabb = (a, b) =>
    a.x < b.x + b.w && a.x + a.w > b.x &&
    a.y < b.y + b.h && a.y + a.h > b.y;

  // --- Input
  const keys = new Set();
  window.addEventListener("keydown", e => {
    if (["ArrowLeft","ArrowRight","Space"].includes(e.code)) e.preventDefault();
    keys.add(e.code);
  }, { passive:false });
  window.addEventListener("keyup", e => keys.delete(e.code));
  let bgmStarted = false;

window.addEventListener("keydown", e => {
  if (!bgmStarted) {
    bgm.play().catch(() => {}); // Safari対策
    bgmStarted = true;
  }
});


  // --- Image
  const faceImg = new Image();
  faceImg.src = "tomo.PNG"; // ファイル名を合わせる

// --- Audio (BGM)
  const bgm = new Audio("bgm.m4a");
  bgm.loop = true;
  bgm.volume = 0.4; // 音量（0.0〜1.0）

  // --- Audio (SE: attack)
const attackSE = new Audio("at.m4a");
attackSE.volume = 0.6;

  // --- Game state
  const W = canvas.width, H = canvas.height;

  const player = {
  x: W/2 - 48,
  y: 70,
  w: 96,
  h: 96,
  speed: 420,
  cooldown: 0
};

  const bullets = []; // {x,y,w,h,vy}
  const enemyBullets = []; // {x,y,w,h,vy}
  let enemyShootTimer = 0;
  const enemyShootInterval = 0.8; // 秒（小さいほど頻繁）
  const enemyBulletSpeed = -520;  // 上向き（マイナス）
  const invaders = []; // {x,y,w,h,alive}
  let score = 0;
  let gameOver = false;
  let win = false;

  // Create invader grid
  const cols = 11, rows = 5;
  const iw = 34, ih = 20, gapX = 16, gapY = 14;
  const startX = 120, startY = H - 200;
  for (let r=0; r<rows; r++) {
    for (let c=0; c<cols; c++) {
      invaders.push({
        x: startX + c*(iw+gapX),
        y: startY + r*(ih+gapY),
        w: iw, h: ih,
        alive: true
      });
    }
  }

  // Invader movement
  let invDir = 1;           // 1 right, -1 left
  let invSpeed = 55;        // px/sec
  let invDrop = -22;         // drop when edge hit
  let invTimer = 0;         // to make stepping feel like classic
  let invStepInterval = 0.22; // sec

  function resetTextLine(y, text) {
    ctx.font = "18px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
    ctx.fillText(text, 18, y);
  }

  function update(dt) {
    if ((gameOver || win) && !bgm.paused) {
  bgm.pause();
}
    if (gameOver || win) return;

    // Player move
    const left = keys.has("ArrowLeft") ? -1 : 0;
    const right = keys.has("ArrowRight") ? 1 : 0;
    player.x += (left + right) * player.speed * dt;
    player.x = clamp(player.x, 10, W - player.w - 10);

    // Shoot
    player.cooldown = Math.max(0, player.cooldown - dt);
    if (keys.has("Space") && player.cooldown === 0) {
      bullets.push({ x: player.x + player.w/2 - 3, y: player.y + player.h + 2, w: 6, h: 12, vy: 700 });
      attackSE.currentTime = 0; // 連射でも毎回鳴らすため
      attackSE.play();
      player.cooldown = 0.18;
    }

    // Enemy shooting
enemyShootTimer += dt;
if (enemyShootTimer >= enemyShootInterval) {
  enemyShootTimer = 0;

  // 生きてる敵からランダムに1体選ぶ
  const aliveInvaders = invaders.filter(i => i.alive);
  if (aliveInvaders.length > 0) {
    const shooter = aliveInvaders[Math.floor(Math.random() * aliveInvaders.length)];

    enemyBullets.push({
      x: shooter.x + shooter.w / 2 - 3,
      y: shooter.y - 12, // 敵の上側から出す（上へ飛ぶので）
      w: 6,
      h: 12,
      vy: enemyBulletSpeed
    });
  }
}


    // Bullets update
    for (const b of bullets) b.y += b.vy * dt;
    for (let i=bullets.length-1; i>=0; i--) {
      if (bullets[i].y + bullets[i].h < 0) bullets.splice(i,1);
    }

// Enemy bullets update
for (const b of enemyBullets) b.y += b.vy * dt;
for (let i = enemyBullets.length - 1; i >= 0; i--) {
  if (enemyBullets[i].y + enemyBullets[i].h < 0) enemyBullets.splice(i, 1);
}


    // Invaders step movement (classic-ish)
    invTimer += dt;
    if (invTimer >= invStepInterval) {
      invTimer = 0;

      // compute alive bounds
      let minX = Infinity, maxX = -Infinity, maxY = -Infinity;
      let aliveCount = 0;
      for (const inv of invaders) if (inv.alive) {
        aliveCount++;
        minX = Math.min(minX, inv.x);
        maxX = Math.max(maxX, inv.x + inv.w);
        maxY = Math.max(maxY, inv.y + inv.h);
      }
      if (aliveCount === 0) { win = true; return; }

      const nextMinX = minX + invDir * invSpeed * invStepInterval;
      const nextMaxX = maxX + invDir * invSpeed * invStepInterval;

      if (nextMinX < 20 || nextMaxX > W - 20) {
        invDir *= -1;
        for (const inv of invaders) if (inv.alive) inv.y += invDrop;
        // speed up as fewer remain
        invSpeed = 55 + (rows*cols - aliveCount) * 1.2;
        invStepInterval = Math.max(0.08, 0.22 - (rows*cols - aliveCount) * 0.002);
      } else {
        for (const inv of invaders) if (inv.alive) inv.x += invDir * invSpeed * invStepInterval;
      }

      // Lose condition: invaders reach player area
      // alive boundsも minY を取る必要があるので追加
  let minY = Infinity;
// for ループ内で minY も更新
// minY = Math.min(minY, inv.y);

  if (minY < player.y + player.h + 10) {
    gameOver = true;
  }

    }

    // Collisions bullets vs invaders
    for (let bi=bullets.length-1; bi>=0; bi--) {
      const b = bullets[bi];
      let hit = false;
      for (const inv of invaders) {
        if (!inv.alive) continue;
        if (aabb(b, inv)) {
          inv.alive = false;
          hit = true;
          score += 10;
          break;
        }
      }
      if (hit) bullets.splice(bi, 1);
    }

// Collisions enemy bullets vs player
for (let i = enemyBullets.length - 1; i >= 0; i--) {
  const b = enemyBullets[i];
  if (aabb(b, player)) {
    enemyBullets.splice(i, 1);
    gameOver = true; // まずは1発アウトでOK
    break;
  }
}


  }

  function render() {
    // background
    ctx.clearRect(0,0,W,H);

    // Stars (cheap)
    ctx.fillStyle = "#0b0f14";
    ctx.fillRect(0,0,W,H);

    // HUD
    ctx.fillStyle = "#d7e0ea";
    resetTextLine(28, `SCORE: ${score}`);

    resetTextLine(52, `MOVE: ← →   SHOT: SPACE`);
resetTextLine(76, `Tip: press any key to start BGM`);


    // Player (face image)
  ctx.drawImage(
    faceImg,
    player.x,
    player.y,
    player.w,
    player.h
  );

    // Bullets
    ctx.fillStyle = "#f7f2a1";
    for (const b of bullets) ctx.fillRect(b.x, b.y, b.w, b.h);

// Enemy Bullets
ctx.fillStyle = "#ff8b8b";
for (const b of enemyBullets) ctx.fillRect(b.x, b.y, b.w, b.h);


    // Invaders
    for (const inv of invaders) {
      if (!inv.alive) continue;
      // body
      ctx.fillStyle = "#7aa2ff";
      ctx.fillRect(inv.x, inv.y, inv.w, inv.h);
      // eyes (tiny)
      ctx.fillStyle = "#0b0f14";
      ctx.fillRect(inv.x + 7, inv.y + 6, 5, 5);
      ctx.fillRect(inv.x + inv.w - 12, inv.y + 6, 5, 5);
    }

    // Messages
    if (win || gameOver) {
      ctx.fillStyle = "rgba(0,0,0,0.65)";
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = "#ffffff";
      ctx.font = "42px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
      ctx.textAlign = "center";
      ctx.fillText(win ? "YOU WIN" : "GAME OVER", W/2, H/2 - 10);
      ctx.font = "18px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
      ctx.fillText("Reload to play again (Cmd+R)", W/2, H/2 + 30);
      ctx.textAlign = "left";
    }
  }

  // Loop
  let last = performance.now();
  function loop(now) {
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
